/**
 * lab6-interrupt_template.c
 *
 * Template file for CprE 288 Lab 6
 *
 * @author Diane Rover, 2/15/2020
 *
 */

#include "Timer.h"
#include "lcd.h"
#include "cyBot_Scan.h"  // For scan sensors
#include <stdbool.h>
#include "open_interface.h"
#include "movement.h"



int main(void) {



    timer_init(); // Must be called before lcd_init(), which uses timer functions
	lcd_init();
    cyBOT_init_Scan(0b0111);
    oi_t *sensor_data = oi_alloc();
    oi_init(sensor_data);
    uart_init();
    cyBOT_init_Scan(0b0111);

    right_calibration_value = 285250; //CyBot 0 calibration
    left_calibration_value = 1214500;

    cyBOT_Scan_t scanner;
    scanData scan[91];
    char sendString[100];

    object detectedObjects[15]; //Number 15 can be changed, this is assumed the maximum amount of objects on the field at one time



    char begin = uart_receive();

    if (begin != 'm') {
        oi_free(sensor_data);
        exit(0);
    }

    char movementDirection;
    while (1) {
        movementDirection = uart_receive();

        switch(movementDirection) {
            case 'w':
                move_forward(&sensor_data, 10);
                break;
            case 's':
                move_backward(&sensor_data, -10);
                break;
            case 'a':
                turn_left(&sensor_data);
                break;
            case 'd':
                turn_right(&sensor_data);
                break;
            case 'q':
                move_degrees_left(&sensor_data, 1);
                break;
            case 'e':
                move_degrees_right(&sensor_data, -1);
    }
        int objectDetection = move_forward(&sensor_data, forward_movement);


        if (objectDetection != 0) {
            move_backward(&sensor_data, -100);
            if (turn_angle >= 0) {
                turn_left(&sensor_data);
                move_forward(&sensor_data, 180);
                turn_right(&sensor_data);
            } else {
                turn_right(&sensor_data);
                move_forward(&sensor_data, 180);
                turn_left(&sensor_data);
            }
            continue;
        }
        break;
    }


    //char begin = uart_receive();


    //move_backward(&sensor_data, -500);


	oi_free(sensor_data);

	return 0;
}
